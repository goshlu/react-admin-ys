浏览器与远程 Web 服务器通过 TCP 三次握⼿来建⽴⼀个 TCP/IP 连接。
⼀旦 TCP/IP 连接建⽴，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远 程服务器收
到请求并找到资源并使⽤ HTTP 响应返回该资源。

响应返回之后，收到客⼾端的应答之后，服务器会关闭TCP/IP连接
客⼾端接受到响应之后就会开始解析下载响应数据 解析html、js、css资源渲染页面

## 前端如何进⾏登录⾝份的判断
前台发送登录请求 后台返回 token，前台得到后台返回的 token，将其写⼊到 localStorage 中，后续
请求中都携带 token 后台判断 token 是否过期，如果过期就对前台的请求响应过期标识或者状态码 前
台得到过期标识后，清除 localStorage 中的 token，然后重定向到 login 路由

## 电商项⽬跟其它项⽬有什么不同
电商⽹站重点在于⽀付购物环节 其他类型的⽹站更多在于内容上⾯的建设

## 经过⼆个⽉“测评项⽬“开发，测试，上线，”测评项⽬“服务于学校实施的第⼀站，参与测评学校的学⽣上午8点集中开测。市场反馈有如下情况：
打开⽹站出现502
登录进不去系统
提交数据⼀致反复
有时出现⽩屏现象

⾸先，502错误，意思是worker忙不过来，参与测评学校的学⽣上午8点集中开测，在短时间内访问
⼈数过多导致积累了⼤量的请求，后台服务器忙不过来。
。解决⽅法贵公司可以看⼀下PHP到底在忙些啥，如果是 CPU 密集型计算（应该不会），看看CPU和内存满没满，没满就多开⼀些worker，满了就
多加⼀些机⼦。我猜测可能是数据库响应缓慢，然后⼈多了数据库是否能撑住也是⼀个考虑，多⽤⼀
些缓存吧。防流量攻击真没啥好办法，找⽜逼⼀些的机房/CDN 吧

结合502报错来看，登录不进系统的原因估计也是短时间内访问⼈数过多导致服务器崩
了。

提交数据⼀直反复就相对复杂了，可能出现的使⽤场景也有很多。
⽐如说我们在提交表单的时候，有可能是⽹络延迟或内存不⾜，导致点击⼀次提交按钮，⻚⾯没有
反应，结果强迫症就犯了，就疯狂的点提交恨不得把⼿机屏幕点烂来。
也有可能是有些⽑孩⼦，点完
提交按钮⽴⻢点击刷新⻚⾯，或直接返回上层⻚⾯想卡bug，不为别的，哎~就是玩⼉。对于这种情况，我以前⼯作的做法就是设置蒙版层，不管你怎么点，只要你点提交，我就给你弹出蒙版层。其实这个问题最根本的原因是程序没有进⾏重复判断，导致数据库重复写⼊。前端后端都可
以添加⼀个重复判断逻辑，判断后台数据库中是否已经存在当前提交的数据，避免重复添加。但是这
种判断只解决了两次表单依次提交的问题，如果不同⽤⼾同时提交表单，数据就不⼀定会正确了。这
种问题就是我们常说的并发问题，并发问题的解决⽅案也有很多，⽐如：加锁排队处理等。

最后提到解决⽩屏问题，我个⼈在⽩屏优化实践上尝试过SSR、预渲染、还有⻣架屏等⼀些⽅案，每
个⽅案都个有⾃⼰的优劣，需要根据实际的业务场景进⾏取舍。
SSR服务端渲染，这个⽅案可以让⻚⾯直接在服务端渲染，但是不利于前后端分离，开发的效率也⽐
客⼾端渲染低，同时也加⼤了服务器的压⼒。⽽且由于地理位置的不同，不同⽤⼾看到的⻚⾯也是不⼀样的，也就是所谓的千⼈千⾯，这也为缓存造成了⼀定困难。

通常是将子应用作为独立的应用进行开发和调式，这样子每一个子应用都可以独立运行，
并修改主应用的配置，让主应用去加载本地启动的子应用，这样子就可以对子应用进行控制，npm-run-all 可以并行处理多个命令


本身qiankun是子应用卸载的时候，将其环境还原到加载前的状态，那么这个和keep-alive
保持之前的状态是有悖的，但是我们在生命周期周期中保存状态不被还原。
启用 preserveEntry 选项，可以保留部分keep-alive的功能。
使用 cachedApps 保存应用状态,手动管理子应用的缓存

使用自定义沙箱机制
使用 Shadow DOM
使用 Shadow DOM 可以进一步隔离子应用的 DOM 和样式，防止样式冲突和 DOM 污染。
scoped css和 css module 防止样式污染
子应用的独立构建和部署 避免在构建过程中共享依赖项和配置文件，保每个子应用的依赖项和配置是独立的，不会相互影响。
避免使用全部变量 ，可以使用状态管理库（如 Redux 或 Vuex）来管理应用状态，避免使用全局变量。

## 项⽬中有没有单独封装组件
那肯定有嘛，在項⽬的 commen ⽂件下会存放项⽬公⽤组件（如：⻚⾯的头组件、⻚⾯底部组件等）项⽬⾥的feature ⽂件下则是放项⽬的功能组件轮播图、分⻚器、上拉加载这些功能组件，表单组件啊，table组件啊

# 在项⽬中发送请求怎么携带token
通过登录获取其他请求方式获取到token，这个时候呢，我们将token添加到请求头中，传递给后端。


## git 版本发⽣冲突你怎么解决的
一般先在本地rebase 远程最新的代码，然后在本地修复冲突，然后在提交解决完冲突的最新代码到远程。

## 如何快速让⼀个盒⼦⽔平垂直居中
flex布局 alignltems:center;justifycontent:center;
绝对定位，上下左右为0，margin:auto;
grid布局
50% trranstlat: -50%；

## ⾸屏加载⽩屏怎么进⾏优化
1. 可能是加载的资源太大了，可以通过配置webpack或者vite来 split chunk，将js分成多个更小的资源来提高加载速度
2. 预加载，像一些js资源或者css资源可以提前加载
3. 配置CDN、缓存等配置，提交获取资源的速度
4. 图片或者视频等提前压缩，
5. 骨架屏，这样的维护成本会更高写些，但是用户体验会更好
6. 路由懒加载
7. 使用SSR服务端渲染

## 路由传参 query与 params区别
query的是?xx=xx的格式，通常会跟在url后面，
params的话，则不会，类似于post请求参数，
query的话，刷新不会丢失参数状态
params的话，刷新路由则参数丢失。需要在路由中占位。


## 项⽬基础优化
1. 减少http请求
2. 减少dom和dom元素的操作 可能会引起重排和重绘
3. 雪碧图
4. 压缩js、css代码
5. css 代码放到首部
6. js代码放入底部
7. img alt记得写


## 对 $nextTick异步渲染的理解
这个通常是用户在dom还没有渲染完成时，需要对dom元素操作，获取为null时使用，
在下一次dom更新结束后执行相关回调函数

在下⼀次 DOM更新结束后执⾏其指定的回调；

## 你是怎么对axios进⾏⼆次封装的，有什么作⽤
1. 设置baseurl
2. 设置请求拦截，和响应拦截
3，添加token，或其他 accept-language等
4. token过期，续期token
5. 处理错误，
6. 设置http 请求超时时间之类的

## ⽤⼾token 失效你是怎么处理的
1. 一般来说时重定向到登录页，并且清除当前缓存的信息
2. 如果存在refresh token的话，我就需要使用refresh token去请求新的token，并保存起来。
3. 或者是接口返回401等状态码，标识token过期了嘛
这个时候呢，清除缓存重定向到登录页面。

## 说⼀下项⽬的流程
1. 项⽬⽴项
2. BA整理项目需求，定排期周期
3. 需求评审，
4. 后端设计数据库，
5. UI出设计图
6. UI评审
7. 前端开始写静态页面，根据后端接口文档写mock数据
8. 联调数据
9. 测试
10. 准备上线


## 请解释⼀下微前端的概念以及它的主要优点和挑战?
微前端是⼀种将不同的前端应⽤组合到⼀起的架构模式。
这些应⽤可以<strong>独⽴开发、独⽴部署、独⽴运⾏</strong>，然后在⼀个主应⽤中进⾏集成。这种模式的主要⽬标是解决⼤型、⻓期演进的前端项⽬的复杂性
> 优点：
1. 解耦：这些项目都可以分解为多个独立开发、测试、部署的小项目，
方便团队分配和提高开发效率，减少团队协作时间
2. 兼容：可以兼容不同的新旧技术栈，
3. 并行开发：因为每个项目都是独立的，所以各个团队之间可以并行开发
4. 独立部署：可以独立部署，减小了部署失败的风险

> 挑战
1. 性能问题： 如果不同的微前端应⽤使⽤了不同的库或框架，可能会导致加载和运⾏的性能问题。
2. 一致性的问题，保持用户体验的一致性，设计和体验上
3. 状态共享，需要使用特殊的工具或模式
4. 复杂性：管理和协调多个独立的应用
5. 安全性：可能会增加跨域的风险


## 你能详细描述⼀下 qiankun 微前端框架的⼯作原理吗？
> 基于single-spa的微前端框架
1. 应用注册与启动
registerMicroApps来注册子应用
应用启动：调用 start 方法启动微前端框架，开始监听路由变化，并根据激活规则加载和渲染子应用。

2. 路由劫持与应用加载
路由劫持：Qiankun 使用 HTML5 History API 或 hashchange 事件来劫持路由变化。当路由发生变化时，Qiankun 检查激活规则，并确定哪个子应用应该被加载和渲染。

应用加载：当一个子应用被激活时，Qiankun 会请求子应用的入口 HTML 页面，并解析其中的 JavaScript 和 CSS 资源。Qiankun 将这些资源注入到主应用的 DOM 中，并执行子应用的 JavaScript 代码。

3. 应用生命周期管理
Qiankun 提供了以下子应用生命周期钩子：

bootstrap：子应用初始化时调用。
mount：子应用每次进入激活状态时调用。
unmount：子应用每次退出激活状态时调用。

4. JavaScript 沙箱与样式隔离
qiankun 通过 Proxy 对象创建了⼀个 JavaScript 沙箱，⽤于隔离⼦应⽤的全局变量，防⽌⼦应⽤之间的全局变量污染。
<DIV>样式隔离：Qiankun 提供了两种样式隔离机制</DIV>
<DIV>动态样式隔离：自动给子应用的 CSS 选择器添加前缀，使其样式只作用于自身。</DIV>
Shadow DOM：通过 Shadow DOM 技术隔离子应用的样式和 DOM。

5. 主应用与子应用通信
Qiankun 提供了基于发布-订阅模式的通信机制，主应用和子应用可以通过 props 传递数据，也可以通过全局状态管理工具（如 Redux、MobX）进行数据共享和同步。

## ⼀个⻚⾯从输⼊ URL 到⻚⾯加载显⽰完成，这个过程中都发⽣了什么？
1. 输入 URL
用户在浏览器地址栏中输入 URL 并按下回车键。
2. DNS 解析
浏览器需要将输入的域名转换为 IP 地址，具体步骤如下：
浏览器缓存：浏览器首先检查其缓存中是否有对应的 IP 地址。
操作系统缓存：如果浏览器缓存中没有找到，浏览器会查询操作系统的缓存。
路由器缓存：如果操作系统缓存中也没有找到，操作系统会向路由器发送 DNS 请求。
ISP DNS 服务器：如果路由器缓存中没有找到，路由器会向 ISP 的 DNS 服务器发送请求。
递归查询：如果 ISP 的 DNS 服务器没有缓存记录，它会进行递归查询，向根域名服务器、顶级域名服务器（TLD）和权威域名服务器逐级查询，直到找到对应的 IP 地址。
3. 建立 TCP 连接
获取到 IP 地址后，浏览器与服务器之间建立 TCP 连接。这个过程包括以下步骤：
三次握手：确保客户端和服务器之间能够可靠通信。
客户端向服务器发送 SYN（同步）包。
服务器收到 SYN 包后，返回 SYN-ACK（同步-确认）包。
客户端收到 SYN-ACK 包后，发送 ACK（确认）包，TCP 连接建立。
4. 发送 HTTP 请求
TCP 连接建立后，浏览器向服务器发送 HTTP 请求。这包括：
请求行：包含请求方法（GET、POST 等）、请求 URL 和 HTTP 版本。
请求头：包含用户代理、接受的内容类型、缓存控制等信息。
请求体：对于 POST 请求，包含表单数据或 JSON 数据等。
5. 服务器处理请求
服务器接收到请求后，进行处理并生成响应：
服务器解析请求：根据请求 URL 路由到相应的处理程序。
处理程序处理请求：访问数据库、执行业务逻辑、读取文件等。
生成响应：生成 HTML、CSS、JavaScript 或其他资源。
6. 服务器返回响应
服务器将生成的响应通过 TCP 连接返回给浏览器。响应包括：
响应状态行：包含 HTTP 版本、状态码（200、404、500 等）和状态描述。
响应头：包含内容类型、内容长度、缓存控制等信息。
响应体：包含 HTML 文档、CSS 文件、JavaScript 文件、图像等资源。
7. 浏览器接收响应
浏览器接收到服务器的响应后，开始处理和渲染页面：
解析 HTML：浏览器解析 HTML 文档，构建 DOM 树。
解析 CSS：浏览器解析 CSS 文件，构建 CSSOM（CSS 对象模型）树。
构建渲染树：浏览器将 DOM 树和 CSSOM 树结合，构建渲染树。
布局：浏览器计算每个节点的几何信息，确定节点的位置和大小。
绘制：浏览器将渲染树绘制到屏幕上。

8. 处理外部资源

在解析 HTML 的过程中，浏览器遇到外部资源（如 CSS 文件、JavaScript 文件、图像等）时，会进行以下操作：

并行请求：浏览器并行下载外部资源。
阻塞解析：对于 CSS 文件和同步 JavaScript 文件，浏览器会阻塞 HTML 解析，直到资源下载并执行完成。
渲染更新：外部资源下载完成后，浏览器会更新渲染树，并重新绘制页面。
9. 执行 JavaScript
浏览器在解析 HTML 和 CSS 的过程中，遇到 JavaScript 文件时，会暂停解析并执行脚本：

同步脚本：同步 JavaScript 脚本会阻塞 HTML 解析，直到脚本执行完成。
异步脚本：异步 JavaScript 脚本不会阻塞 HTML 解析，可以并行下载和执行。
10. 触发 DOMContentLoaded 事件
当初始的 HTML 文档被完全加载和解析时，浏览器会触发 DOMContentLoaded 事件。
11. 触发 Load 事件
当所有资源（包括图片、样式表、脚本等）都被加载完成后，浏览器会触发 load 事件。





